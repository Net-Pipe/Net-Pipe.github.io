<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss>

  
  <item>
    <title>状态压缩</title>
    <link>/post/%E7%AE%97%E6%B3%95/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/</link>
    
    <summary>用二进制数存储 bool 数组.</summary>
    
    <content>
      简介 ¶由于 bool 变量只有 0 和 1 两种值，二进制位也具备此特征，故每个 bool 数组都可用一个二进制数表示. 将 bool 数组 a（长为 n）用 n 位二进制数表示，它的第 i 位表示 a[i]. 状态压缩的相关操作方法：    操作 运算     取出第 k 位数 (n &amp;gt;&amp;gt; (k - 1)) &amp;amp; 1   将第 k 位取反 n ^= (1 &amp;lt;&amp;lt; (k - 1))   将第 k 位赋值为 1 n |= (1 &amp;lt;&amp;lt; (k - 1))   将第 k 位赋值为 0 n &amp;amp;= ~ (1 &amp;lt;&amp;lt; (k - 1))    lowbit 运算 ¶lowbit(n)：n 在二进制下「最低位的 1 和其后所有的 0」构成的数. 例：n=(101000)_2，lowbit(n)=(1000)_2. n_i：n 在二进制下的第 i 位数字.  设 n_k=1，n_0\cdots n_{k-1}=0.  将 n 的每一位取反，此时 n_k=0，n_0\cdots n_{k-1}=1，其余位和原来相反. 再令 n=n&#43;1，此时 n_k=1，n_0\cdots n_{k-1}=0，其余位仍和原来相反. 因此 n\&amp;amp;(\sim n&#43;1) 仅有第 k 位为 1.  由于在补码表示下 -n=\sim n&#43;1，故  
    </content>
  </item>
  

  
  <item>
    <title>高精度</title>
    <link>/post/%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/</link>
    
    <summary>支持高位数的运算系统.</summary>
    
    <content>
      简介 ¶高精度是支持高位数的运算系统. 本章仅介绍最常用的正整数运算系统. 构造 ¶在 vector&amp;lt;int&amp;gt; 容器内保存每位数字，并实现自动处理进位.  vector&amp;lt;int&amp;gt; 的位数要从 0 记起（第 0 位，第 1 位，\cdots）.  输入 ¶取出字符串的每一位，倒序存入数组. 输出 ¶数据是倒序储存的，故倒序输出. 比较 ¶先比较位数. 若位数相同，则从高位到低位逐位比较. 加法 ¶从低位到高位，将两数对应位置相加. 先实现 &#43;= 方法，节省传参时间. 减法 ¶返回差的绝对值. 从低位到高位，将两数对应位置相减. 不够减要借位. 乘法 ¶将 a 的第 i 位乘 b 的第 j 位累加在答案的第 i&#43;j 位上. 除法 ¶先实现带余除法函数，再重载符号方法. 将 b 和 a 最高位对齐，重复相减，统计减的次数. 
    </content>
  </item>
  

  
  <item>
    <title>搜索</title>
    <link>/post/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/</link>
    
    <summary>运用计算机的高性能枚举问题的答案.</summary>
    
    <content>
      简介 ¶搜索算法：枚举问题的所有可能答案，并逐一校验. 设集合 A 满足以下性质 已知 3\in A，问 23\in A 是否成立？ A 的性质可抽象为下图：  以 3 为树根，向下拓展树形图. 树中的所有节点都属于 A. 于是只需查找 23 是否在树中.  对于复杂的问题，可以先抽象出关系图，再搜索求解. 广度优先搜索（BFS） ¶广度优先搜索（Breadth First Search，BFS）按层次搜索节点. 其原理如下：  建立空队列. 将根节点入队. 取出队头，将其所有子节点入队. 重复上一步直到队列为空.  BFS 搜索该图的步骤：           节点 1 入队 节点 1 出队，2,3 入队 节点 2 出队，4,5 入队 节点 3 出队，6,7 入队 节点 4 出队 节点 5 出队 节点 6 出队 节点 7 出队                      同一个节点不能被重复访问，否则将导致死循环.  深度优先搜索（DFS） ¶深度优先搜索（Depth First Search，DFS）尽可能往更深处搜索节点. 其本质是递归. DFS 搜索该图的步骤：           访问根节点 1.  访问子节点 2.  访问子节点 4. 访问子节点 5.   访问子节点 3.  访问子节点 6. 访问子节点 7.                          同一个节点不能被重复访问，否则将导致死循环.  多维度搜索：前驱 ¶搜索二维数组 a[n,m] 时，a[i,j] 抽象为节点 (i,j). 其子节点为 (i&#43;1,j),(i-1,j),(i,j&#43;1),(i,j-1)，即与其相邻的四个节点.  现在从某个节点开始搜索，枚举子节点的工作就显得繁琐. 以 DFS 为例： 届时可以通过前驱节省工作量. 
    </content>
  </item>
  

  
  <item>
    <title>二分</title>
    <link>/post/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/</link>
    
    <summary>据说只有 10% 的程序员能写对二分.</summary>
    
    <content>
      简介 ¶玩个游戏.  想一个 1000 以内的正整数 n. 每次我给出一个整数 x，告诉我「n&amp;gt;x」「n&amp;lt;x」或「n=x」.  我能保证在 10 次以内猜到它. 首先我猜 x=500. 除了正好猜中以外，我能把 n 的范围缩小一半.  n&amp;gt;x\intro n\in[501,1000] n&amp;lt;x\intro n\in[1,499]  然后如法炮制，重复给出可行范围的中间数，每次都能把范围折半. 由于 \log_2{1000}&amp;lt;10，最多 10 次就能确定 n.     例   n=324：  x=500. n&amp;lt;x\intro n\in[1,499]. x=250. n&amp;gt;x\intro n\in[251,499]. x=375. n&amp;lt;x\intro n\in[251,375]. x=313. n&amp;gt;x\intro n\in[313,375]. x=344. n&amp;lt;x\intro n\in[313,344]. x=328. n&amp;lt;x\intro n\in[313,328]. x=320. n&amp;gt;x\intro n\in[320,328]. x=324. n=x.    条件 ¶数组须呈现广义上的「单调性」. 将数组 a 对半分，前段都不满足 P，后段都满足 P，则可用二分算法确定分割点，进而确定「第一个满足 P 的元素」. 原理 ¶查找数组 a（长度 n）中第一个满足条件 P 的元素： Q &amp;amp; A ¶作者列出了大家在学习二分算法中的一些疑问和解答，供参考学习.  Q：为何循环的条件是 l&#43;1&amp;lt;r？我在其他参考书上看的是 l&amp;lt;r. A：在我的版本中，当 l&#43;1=r 时，a[l] 或 a[r] 就是要找的分割点，此时应退出循环. 故循环能进行的条件是 l&#43;1&amp;lt;r.   Q：针对一段数组区间，比如对 a[L\cdots R] 进行二分查找怎么办？ A：在程序开头令 l=L-1,r=R&#43;1，此举的目的是保证 m=\left\lfloor\dfrac{ l&#43;r}{2}\right\rfloor 能取到范围端点 L 或 R.   Q：m 会溢出 [L,R] 的范围吗？ A：不会. 那时已因不满足 l&#43;1&amp;lt;r 而退出循环了.   Q：如果反过来，数组 a 的前段满足 P，后段不满足 P 怎么办？ A：我们把两种情况都讨论一遍. 若前段（a[1\cdots l]）不满足 P，后段（a[r\cdots n]）满足 P：  a[l] 总不满足 P，a[r] 总满足 P. 因此当 a[m] 满足 P 时，应令 r=m，否则令 l=m. 第一个满足 P 的是 a[r].  若前段（a[1\cdots l]）满足 P，后段（a[r\cdots n]）不满足 P：  a[l] 总满足 P，a[r] 总不满足 P. 因此当 a[m] 满足 P 时，应令 l=m，否则令 r=m. 最后一个满足 P 的是 a[l].   整数域上的二分 ¶在单调递增数组 a（长度 n）中查找第一个 \ge x 的数： 前段 &amp;lt;x，后段 \ge x，因此 a[m]\ge x 时应令 r=m，最终答案是 a[r]. 在单调递增数组 a（长度 n）中查找最后一个 \le x 的数： 前段 \le x，后段 &amp;gt; x，因此 a[m]\le x 时应令 l=m，最终答案是 a[l]. 实数域上的二分 ¶实数域上的二分需要指定精度 eps，以 l&#43;eps&amp;lt;r 为循环条件. 此外还可采用固定次数的二分. 此方法得到的答案精度通常更高. 
    </content>
  </item>
  

  
  <item>
    <title>排序</title>
    <link>/post/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</link>
    
    <summary>你听说过猴子排序吗？</summary>
    
    <content>
      简介 ¶排序数组 a（长度 n）中的元素. 本章只研究升序排序. 选择排序 ¶在第 i 次遍历中，交换 a[i] 和第 i 小的数. 时间复杂度：O(n^2). 冒泡排序 ¶重复扫描数组 a. 若 a[i]&amp;gt;a[i&#43;1] 就交换它们. 当没有可交换元素时结束排序. 时间复杂度：O(n^2). 插入排序 ¶将数组 a 分为「已排序」和「未排序」区. 每次将「未排序」区的一个元素插入「已排序区」的正确位置. 时间复杂度：O(n^2). 计数排序 ¶记录每个元素出现的次数，然后依次输出. f[x]：数字 x 出现了几次. 时间复杂度：O(n). 不适用于大范围元素. 快速排序 ¶ 设定基准数为数组的中间数 a[m]. 扫描数组，将所有比 a[m] 小的元素移至其左，大于 a[m] 的元素移至其右. 对 a[m] 左右的子数组进行相同操作.  平均时间复杂度：O(n\log n). 最坏时间复杂度：O(n^2). 归并排序 ¶ 将数组分为 a[l\sim m] 和 a[m&#43;1\sim r] 两个子数组. 递归排序两个子数组. 合并两个已排序的子数组.  设定指针 i 和 j，最初位置分别为两个子数组的起始位置. 比较 a[i] 和 a[j]，选择更小的放入数组 b ，并移动其指针向下一位置. 重复上一步直到某指针超出数组末尾. 将子数组剩下的所有元素放入数组 b，再将数组 b 拷贝到数组 a.    时间复杂度：O(n\log{n}). 猴子排序 ¶随机交换两个元素，直到排完序. 平均时间复杂度：O(n\cdot n!). 最好时间复杂度：O(n). 最坏时间复杂度：O(\infty). 逆序对数 ¶若 i&amp;lt;j 且 a[i]&amp;gt;a[j]，则 (a[i],a[j]) 是一组逆序对. 在 归并排序 的第 3 步：合并两个有序数组时，若出现 a[i]&amp;gt;a[j] 的情况，由 i&amp;lt;j 可知 a[i\sim m] 和 a[j] 构成了 m-i&#43;1 个逆序对，便可以统计到答案中. 稳定性 ¶若在原数组中，任意相同元素在排序前后的相对位置不变，则此排序是稳定的. 稳定排序不会破坏相同元素的原顺序. 例如对于结构体 Student： 现给出已按 id 排序的 Student 数组，要求按 score 再排序. 稳定排序能保证所有 score 相同的 Student 仍按照 id 排序.    算法 是否稳定 算法 是否稳定     选择排序 \times 快速排序 \times   冒泡排序 \sqrt{} 归并排序 \sqrt{}   插入排序 \sqrt{} 猴子排序 \times   记数排序 \sqrt{}      
    </content>
  </item>
  

  
  <item>
    <title>递归</title>
    <link>/post/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/</link>
    
    <summary>递归的定义：参见递归.</summary>
    
    <content>
      简介 ¶你去找银行经理办事.   经理 A：不关我的事. 找经理 B.   经理 B：不关我的事. 找经理 A.   于是你在两个经理之间往返奔波了一整天. 在程序中，该行为称作「递归」. 直接递归 ¶函数 f() 在内部调用了它自己. 它会永久运行下去. 间接递归 ¶这类似于两个银行经理的情况. 边界条件 ¶合法的递归需要边界条件，使函数在恰当的时机停止，而不是永久运行. 例 1 ¶计算阶乘 n!. f(n)=n! 可以定义为 运行 f(3):  A：来人，计算 f(3).  B：来人，计算 f(2).  C：来人，计算 f(1).  D：来人，计算 f(0).  E：报告，f(0)=1.   D：报告，f(1)=f(0)\times 1=1.   C：报告，f(2)=f(1)\times 2=2.   B：报告，f(3)=f(2)\times 3=6.   A：报告，f(3)=6.  例 2 ¶计算斐波那契数列的第 i 项. 
    </content>
  </item>
  

</rss>

